async fn send_best_block(
    client: &Client,
    endpoint: &str,
    oracle: &str,
    oracle_pk: &str,
    abi_path: &str,
    contract_addr: &str,
    chain: &str,
) -> Result<(), web3::Error> {
    // Load the chain
    let transport = Http::new(chain).unwrap();
    let web3 = Web3::new(transport);

    // Load the ABI
    let abi = std::fs::read(abi_path).expect("Failed to read ABI file");
    let contract_abi = ethabi::Contract::load(&*abi).expect("Failed to parse ABI");

    // Set up the contract
    let contract_address: Address = contract_addr.parse().unwrap();
    let contract = Contract::new(web3.eth(), contract_address, contract_abi);

    // Get the best block information
    let best_hash = get_best_hash(client, endpoint).await.unwrap();
    let best_block = get_best_block(client, endpoint, &best_hash).await.unwrap();
    let previous_block_hash = H256::from_slice(
        &hex::decode(
            best_block["previousBlockHash"]
                .as_str()
                .unwrap()
                .trim_start_matches("0x"),
        )
        .unwrap(),
    );
    let merkle_root_hash = H256::from_slice(
        &hex::decode(
            best_block["merkleRootHash"]
                .as_str()
                .unwrap()
                .trim_start_matches("0x"),
        )
        .unwrap(),
    );

    // Prepare the function call
    let function_name = "setChainTip";
    let params = vec![
        Token::Bytes(previous_block_hash.to_fixed_bytes().to_vec()),
        Token::Bytes(merkle_root_hash.to_fixed_bytes().to_vec()),
    ];

    // Get the nonce for the transaction
    let nonce = web3
        .eth()
        .transaction_count(oracle.parse().unwrap(), None)
        .await?;

    // Prepare the transaction options
    let options = Options {
        gas: Some(1_000_000.into()),
        gas_price: Some(10_000_000_000u64.into()),
        nonce: Some(nonce),
        ..Default::default()
    };

    // Prepare the transaction data
    let tx_data = contract
        .abi()
        .function(function_name)
        .unwrap()
        .encode_input(&params)
        .unwrap();

    // Create TransactionParameters
    let tx_parameters = TransactionParameters {
        to: Some(contract_address),
        data: Bytes(tx_data),
        gas: options.gas.unwrap(),
        gas_price: Some(options.gas_price.unwrap()),
        value: options.value.unwrap_or_else(U256::zero),
        nonce: options.nonce,
        ..Default::default()
    };

    // Sign the transaction
    let secret_key = SecretKey::from_slice(&hex::decode(oracle_pk).unwrap()).unwrap();
    let signed_tx = web3
        .accounts()
        .sign_transaction(tx_parameters, &secret_key)
        .await?;

    // Send the signed transaction
    let tx_hash = web3
        .eth()
        .send_raw_transaction(signed_tx.raw_transaction)
        .await?;

    println!("Transaction hash: {:?}", tx_hash);

    Ok(())
}
